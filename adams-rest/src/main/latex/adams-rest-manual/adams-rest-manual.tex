% This work is made available under the terms of the
% Creative Commons Attribution-ShareAlike 4.0 license,
% http://creativecommons.org/licenses/by-sa/4.0/.

\documentclass[a4paper]{book}

\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{multirow}
\usepackage{scalefnt}
\usepackage{tikz}

% watermark -- for draft stage
%\usepackage[firstpage]{draftwatermark}
%\SetWatermarkLightness{0.9}
%\SetWatermarkScale{5}

\input{latex_extensions}

\title{
  \textbf{ADAMS} \\
  {\Large \textbf{A}dvanced \textbf{D}ata mining \textbf{A}nd \textbf{M}achine
  learning \textbf{S}ystem} \\
  {\Large Module: adams-rest} \\
  \vspace{1cm}
  \includegraphics[width=2cm]{images/rest-module.png} \\
}
\author{
  Peter Reutemann
}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\begin{document}

\begin{titlepage}
\maketitle

\thispagestyle{empty}
\center
\begin{table}[b]
	\begin{tabular}{c l l}
		\parbox[c][2cm]{2cm}{\copyright 2018-2019} &
		\parbox[c][2cm]{5cm}{\includegraphics[width=5cm]{images/coat_of_arms.pdf}} \\
	\end{tabular}
	\includegraphics[width=12cm]{images/cc.png} \\
\end{table}

\end{titlepage}

\tableofcontents
%\listoffigures
%\listoftables

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
REST webservices (\cite{rest}) are a popular variant of webservices, that
are quite often easier to implement than full-blown SOAP-based ones (\cite{soap}).

ADAMS provides a general framework for accessing and implementing REST webservices.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Using REST}
The following sections describe how you can access REST webservices and write
your own ones.

\section{Accessing a web-service}
There are two options for accessing a webservice: custom code for sending/receiving
data or generic processing in the flow itself.

\subsection{Custom code}
When using custom code, you can use one of the following superclasses to derive
your own code from:
\begin{tight_itemize}
  \item adams.flow.rest.AbstractRESTClientSource
  \item adams.flow.rest.AbstractRESTClientTransformer
  \item adams.flow.rest.AbstractRESTClientSink
\end{tight_itemize}
These classes are generics and require you to supply the input and/or output
types, override methods for integrating them in the flow (accepts/generates)
and methods for handling input/output data.
These superclasses are available in the flow through the following, corresponding
actors:
\begin{tight_itemize}
  \item adams.flow.source.RESTSource
  \item adams.flow.transformer.RESTTransformer
  \item adams.flow.sink.RESTSink
\end{tight_itemize}

The \textit{adams.flow.rest.echo.EchoClientTransformer} class is a simple
example that sends a UTF-8 string it receives to an Echo REST server, which simply
returns the same data. In the \verb|doQuery()| method, a URL is constructed
from the URL of the echo server and the URL-encoded string that is to be sent
to the server. The actual sending via the \verb|GET| method is handled by the
\verb|adams.core.net.HttpRequestHelper| class. The response from the echo
server is then decoded from a UTF-8 string and forwarded in the flow.

{\scriptsize
\begin{verbatim}
package adams.flow.rest.echo;
import adams.core.base.BaseURL;
import adams.core.net.HttpRequestHelper;
import adams.flow.container.HTMLRequestResult;
import adams.flow.rest.AbstractRESTClientTransformer;
import org.jsoup.Connection.Method;
import java.net.URLDecoder;
import java.net.URLEncoder;

public class EchoClientTransformer
  extends AbstractRESTClientTransformer<String,String> {

  protected String m_RequestData;

  public String globalInfo() {
    return "Client (transformer) for Echo REST service.";
  }

  public Class[] accepts() {
    return new Class[]{String.class};
  }

  public Class[] generates() {
    return new Class[]{String.class};
  }

  public void setRequestData(String value) {
    m_RequestData = value;
  }

  protected void doQuery() throws Exception {
    String		url;
    HTMLRequestResult 	result;

    if (getUseAlternativeURL())
      url = getAlternativeURL();
    else
      url = new EchoServer().getDefaultURL();
    url += "echo/" + URLEncoder.encode(m_RequestData, "UTF-8");
    result = HttpRequestHelper.send(new BaseURL(url), Method.GET, null, null);
    if (result.getValue(HTMLRequestResult.VALUE_STATUSCODE, Integer.class) == 200)
      setResponseData(URLDecoder.decode(result.getValue(HTMLRequestResult.VALUE_BODY, String.class), "UTF-8"));
    else
      m_LastError = result.getValue(HTMLRequestResult.VALUE_STATUSCODE) + ": "
          + result.getValue(HTMLRequestResult.VALUE_STATUSMESSAGE);
  }
}
\end{verbatim}}

\subsection{Generic flow}
Using the above example of accessing an echo server, we can simply use existing
component available through the flow\footnote{See example flow: adams-rest-use\_service.flow}:
\begin{tight_itemize}
  \item The string to be sent to the server would be encoded via the \verb|URLEncode|
  conversion.
  \item This string would then be prefixed with the URL of the actual server
  (e.g., \verb|http://localhost:8080/echo/|) to construct the complete URL.
  \item Via the \verb|HTTPRequest| source, you can then connect to the
  complete URL. Choose the correct method for accessing, like \verb|GET|
  or \verb|POST|. This source actor allows you to attach additional headers and
  parameters as key-value pairs to your request. Cookies are accessed through
  storage, expecting a map object.
  \item Using the \verb|ContainerValuePicker| control actor, the response
  returned by the echo server can be retrieved.
  \item With the \verb|URLDecode| conversion, the URL encoded response can
  be turned into a regular string again.
\end{tight_itemize}

\section{Creating a web-service}
TODO

\subsection{Context}
If your REST service components require a context, e.g., flow context, then
you have to use the following approach for setting up the service
factory\footnote{\url{http://cxf.apache.org/docs/jaxrs-services-configuration.html}{}}:
\begin{verbatim}
JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
CustomerService cs = new CustomerService();
// set context in CustomerService service bean
sf.setServiceBeans(cs);
sf.setAddress("http://localhost:9080/");
sf.create();
\end{verbatim}
By instantiating the \textit{beans} yourself rather than through the factory,
you can provide them with context. You then use the \textit{setServiceBean(s)}
methods to set one or more beans.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Flow}
This module contains generic actors in which you can simply plug your 
web-services that you have implemented. In the following a short overview.

The following standalones are available:
\begin{tight_itemize}
	\item \textit{RESTServer} -- runs a web-service. waiting for
	requests\footnote{adams-rest-server.flow}.
\end{tight_itemize}
The following sources are available:
\begin{tight_itemize}
	\item \textit{RESTSource} -- queries a web-service and forwards the received
	data\footnote{adams-rest-echo\_source.flow}.
\end{tight_itemize}
The following transformers are available:
\begin{tight_itemize}
	\item \textit{RESTTransformer} -- sends the data it receives to a web-service
	and forwards the data from the response in
	turn\footnote{adams-rest-echo\_transformer.flow}.
\end{tight_itemize}
The following sinks are available:
\begin{tight_itemize}
	\item \textit{RESTSink} -- simply sends data to a web-service\footnote{adams-rest-echo\_sink.flow}.
\end{tight_itemize}

\section{TLS support}
TLS support is automatically configured in case the URL uses \verb|https://| as
protocol and the \verb|RESTUtils.configureClient| method is called. The following
standalones have to be present (and configured) in that case:
\begin{tight_itemize}
  \item \textit{KeyManager}
  \item \textit{TrustManager}
  \item \textit{SSLContext} -- optional, only used to determine the version of the
  TLS protocol (fallback is \textit{TSL}).
\end{tight_itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{bibliography}

\end{document}
